提示：新建maven模块项目，删除src文件夹，以下在maven模块中新建

一、服务端
1.在maven下创建springboot项目
2.添加 eureka-server 依赖
3.编写yml文件，主要有：
    端口（server-port）
    项目名称（application-name），指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问
    eureka配置，主要有：
        registerWithEureka: false  #默认true 是否向server注册
        fetchRegistry: false   #默认true 是否向server获取注册表
         service-url:
             defaultZone: 地址   #多个可以用“，”隔开

3.启动文件处添加配置@EnableEurekaServer，声明为注册中心
4.多个服务可相互注册，单要在yml去掉注释registerWithEureka和fetchRegistry

二、客户端
1.在maven下创建springboot项目
2.在pom中添加eureka-client依赖
3.编写yml配置文件
    端口（server-port）
    项目名称（application-name），指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问
    eureka配置，主要有：
         service-url:
             defaultZone: 地址
4.在启动文件中添加@EnableDiscoveryClient(f版中可去掉)，向注册中心注册

三、消费者客户端调用方式（负载均衡）
① ribbon（负载均衡微服务中的应用）
    1.如二创建客户端
    2.添加ribbon依赖（f版中无需添加，spring-cloud-starter-netflix-eureka-client 里边已经包含了 spring-cloud-starter-netflix-ribbon）
    3.重写RestTemplate方法 并添加注解 @LoadBalanced
    4.使用RestTemplate返回服务地址：url=http://服务名/要调用的服务端口  （服务名会被解析为ip+port）

② LoadBalancerClient方式
    1.如二创建客户端
    2.重写RestTemplate方法
    3.获取LoadBalancerClient实例，LoadBalancerClient.choose("服务端名称")获取要调用的服务端名称
    4.把获取的ip及端口放入url中（LoadBalancerClient会按规则获取相应的服务）

③ Feign（实际开发常用，其内部默认使用了ribbon）
    1.如二创建客户端
    2.添加openfeign依赖
    3.在启动类上添加@EnableFeignClients开启feign
    4.添加Feign接口类
        类上添加注解 @FeignClient(name = "服务名")
        方法需和对应的服务的方法名和参数名一致
    5.添加访问类，实现接口，方法内调用接口的方法

四、服务熔断（解决雪崩）--Feign Hystrix
    1.创建如三-③所示项目，Hystrix所依赖项已包含在feign内
    2.在yml中的feign下开启hystrix
        feign:
          hystrix:
            enabled: true
    3.添加feign的实现类，该类会在无法找到对应服务后执行
    4.在feign接口类上FeignClient增添fallback
    5.测试结果（俩服务）：关掉一个服务，刚开始会执行回执，之后再也不会；全关，一直执行回执；
    6.熔断监控面板
         单体：hystrix-dashboard
               ① 创建springboot项目
               ② 添加依赖netflix-hystrix和netflix-hystrix-dashboard
               ③ 在启动类上添加@EnableHystrixDashboard
               ④ 访问地址为:ip:port/histrix(此不是项目名，固定hystrix)，第一行为监听的地址，下面为延迟和标题
               ⑤ 添加监听点，在熔断机制的项目上添加依赖netflix-hystrix和actuator
               ⑥ 在熔断机制的项目上的yml添加配置：
                        management:
                           endpoints:
                             web:
                               exposure:
                                 include: hystrix.stream
               ⑦ 在熔断机制的项目上的启动类添加@EnableHystrix
               ⑧ 打开第④步骤的地址，在第一行输入http://熔断机制项目ip及端口/actuator/hystrix.stream，点击监听流。

         turbine：略

五、配置中心（Client和Server）
    1.server（提供配置文件的存储、以接口的形式将配置文件的内容提供出去）
        ① 创建springcloud微服务项目，添加config-server依赖
        ② 在配置文件：
            spring:
              cloud:
                config:
                  server:
                    git:
                      uri: https://github.com/hhsyy/config-repo-test # 配置git仓库的地址
                      search-paths: test #此为仓库下的文件夹地址，可以配置多个，用,分割。
                      username:
                      password:

            提示：设置spring.profiles.active=native，可从本地获取配置(默认src/main/resource下，指定可以file:E:/绝对路径)
        ③ 启动类添加 @EnableConfigServer
        ④ 访问 http://127.0.0.1:8112/config-client/dev（服务端的数据是实时改变的），http://127.0.0.1:8112/config-client-dev.yml可直接查看yml文件
        ⑤ github上的配置文件命名规则
            /{application}/{profile}[/{label}]
            /{application}-{profile}.yml
            /{label}/{application}-{profile}.yml
            /{application}-{profile}.properties
            /{label}/{application}-{profile}.properties

    2.client（通过接口获取数据、并依据此数据初始化自己的应用）
        ① 创建springcloud微服务项目，添加config依赖
        ② 填好yml端口项目名，新建一个bootstrap.yml项目（会比application提前加载），eureka配置也写在这，填写
            spring:
              cloud:
                config:
                  name: config-client # http://127.0.0.1:8112/config-client-dev.yml对应 {application} 部分
                  profile: dev # http://127.0.0.1:8112/config-client-dev.yml对应 {profile} 部分
                  label: master # 仓库对应 {label} 部分，即 Git 的分支。如果配置中心使用的是本地存储，则该参数无用
                  discovery:
                   enabled: true #开启 Config 服务发现支持
                   service-id: config-server
        ③ 编写测试类测试是否获取成功（此客户端不能实时刷新数据）
        ④ 简单实现实时刷新，添加依赖actuator，测试类添加@RefreshScope，每当执行/actuator/refresh数据便会刷新（每次执行都会很麻烦，可用GitHub数据更新后回执执行这个地址，即webhook）

    3.消息总线（Spring Cloud Bus）
        ① webhook方式：主动刷新客户端方式
        ② 消息总线：当配置改变时，config-server就通知消息总线（需执行url），消息总线就通知客户端获取config-server的配置（主要使用mq，kafka或rabbitmq等）
           以上面项目为基础
           1>:以rabbitmq为例
           2>:config-server端
                添加依赖 actuator和bus-amqp（bus-kafka）
                config-server yml 添加bus（开启bus）、rabbitmq（添加消息队列配置）、management配置
                当github的配置更新时，执行http://127.0.0.1:8112/actuator/bus-refresh（post），会推送至客户端更新配置
           3>:config-client端
                添加依赖bus、actuator、bus-amqp
                yml添加bus（开启bus）、rabbitmq（添加消息队列配置）
                当github的配置更新时，服务端执行刷新，就能收到一改变的配置







